/*
 * generated by Xtext 2.9.1
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import minilang.Block;
import minilang.CallMethod;
import minilang.Constant;
import minilang.GreaterThan;
import minilang.IfStmt;
import minilang.Line;
import minilang.Method;
import minilang.MinilangPackage;
import minilang.Modulo;
import minilang.Move;
import minilang.Program;
import minilang.RotateLeft;
import minilang.RotateRight;
import minilang.Sum;
import minilang.Variable;
import minilang.VariableAffect;
import minilang.VariableRef;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinilangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinilangPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MinilangPackage.CALL_METHOD:
				sequence_CallMethod(context, (CallMethod) semanticObject); 
				return; 
			case MinilangPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case MinilangPackage.GREATER_THAN:
				sequence_GreaterThan(context, (GreaterThan) semanticObject); 
				return; 
			case MinilangPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case MinilangPackage.LINE:
				sequence_Line(context, (Line) semanticObject); 
				return; 
			case MinilangPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case MinilangPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case MinilangPackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case MinilangPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MinilangPackage.ROTATE_LEFT:
				sequence_RotateLeft(context, (RotateLeft) semanticObject); 
				return; 
			case MinilangPackage.ROTATE_RIGHT:
				sequence_RotateRight(context, (RotateRight) semanticObject); 
				return; 
			case MinilangPackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			case MinilangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MinilangPackage.VARIABLE_AFFECT:
				sequence_VariableAffect(context, (VariableAffect) semanticObject); 
				return; 
			case MinilangPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CallMethod
	 *     CallMethod returns CallMethod
	 *
	 * Constraint:
	 *     method=[Method|EString]
	 */
	protected void sequence_CallMethod(ISerializationContext context, CallMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.CALL_METHOD__METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.CALL_METHOD__METHOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallMethodAccess().getMethodMethodEStringParserRuleCall_3_0_1(), semanticObject.getMethod());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     value=EDouble?
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns GreaterThan
	 *     GreaterThan returns GreaterThan
	 *
	 * Constraint:
	 *     (left=Value right=Value)
	 */
	protected void sequence_GreaterThan(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterThanAccess().getLeftValueParserRuleCall_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterThanAccess().getRightValueParserRuleCall_5_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStmt
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (thenBranch=Block elseBranch=Block? condition=Condition)
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Line returns Line
	 *
	 * Constraint:
	 *     (x1=EDouble? y1=EDouble? x2=EDouble? y2=EDouble?)
	 */
	protected void sequence_Line(ISerializationContext context, Line semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (name=EString block=Block)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.METHOD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.METHOD__NAME));
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.METHOD__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.METHOD__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMethodAccess().getBlockBlockParserRuleCall_4_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Modulo
	 *     Modulo returns Modulo
	 *
	 * Constraint:
	 *     (right=Value left=Value)
	 */
	protected void sequence_Modulo(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__RIGHT));
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuloAccess().getRightValueParserRuleCall_2_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getModuloAccess().getLeftValueParserRuleCall_4_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Move
	 *     Move returns Move
	 *
	 * Constraint:
	 *     {Move}
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         x=EDouble? 
	 *         y=EDouble? 
	 *         angle=Cardinals? 
	 *         distance=EDouble? 
	 *         mainMethod=[Method|EString] 
	 *         (methods+=Method methods+=Method*)? 
	 *         (variables+=Variable variables+=Variable*)? 
	 *         (lines+=Line lines+=Line*)?
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RotateLeft
	 *     RotateLeft returns RotateLeft
	 *
	 * Constraint:
	 *     {RotateLeft}
	 */
	protected void sequence_RotateLeft(ISerializationContext context, RotateLeft semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RotateRight
	 *     RotateRight returns RotateRight
	 *
	 * Constraint:
	 *     {RotateRight}
	 */
	protected void sequence_RotateRight(ISerializationContext context, RotateRight semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Sum
	 *     Sum returns Sum
	 *
	 * Constraint:
	 *     (right=Value left=Value)
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__RIGHT));
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.BINARY_OPERATION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getRightValueParserRuleCall_2_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getSumAccess().getLeftValueParserRuleCall_4_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableAffect
	 *     VariableAffect returns VariableAffect
	 *
	 * Constraint:
	 *     (variable=[Variable|EString] value=Value)
	 */
	protected void sequence_VariableAffect(ISerializationContext context, VariableAffect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.VARIABLE_AFFECT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.VARIABLE_AFFECT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.VARIABLE_AFFECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.VARIABLE_AFFECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAffectAccess().getVariableVariableEStringParserRuleCall_1_0_1(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getVariableAffectAccess().getValueValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[Variable|EString]
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinilangPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinilangPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableVariableEStringParserRuleCall_3_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=EString value=EDouble?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
